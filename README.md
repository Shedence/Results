# Result
Таск №1 на обнаружение вредоносного ip-адреса.
С помощью утилиты tcpdump исследуем трафик удаленной машины, по условию сказано, что нужно прослушивать только порт 224. Используя команду ssh залогинемся на удаленном сервере под пользвателем root и паролем, выданным организаторами. Запуска анализатор трафика командой tcpdump -i ens224. Можно увидеть 4 ip-адреса, среди которых 3 роутера и один атакующий. Если произошел обмен ключами, то шифрование происходит путем ксорирования с клчом, длинной 16. Проанализировав трафик, найди ip атакующих и сдам задачу.
 
 
 
 
 
 Таск 2.
 Разархивируем архив. Получаем файл с расширением .img, который можно открыть предустановленным архиватором 7-ZIP на Windows или командой mount <имя файла> <дириктория для распаковки>. В результате получаем множество папок и файлов, среди которых должен находиться вреденосный файл. Последовательно с помошью программ IDA или GHIDRA.
 
 
 
 Таск 3.
 Разархивируем архив. Получаем файл с расширением .img, который можно открыть предустановленным архиватором 7-ZIP на Windows или командой mount <имя файла> <дириктория для распаковки>.
Передача данных происходит с помощью tcp_header->seq, tcp_header->ack_seq, tcp_header->check
Значение tcp_header->seq == 0х12345678 означает начало передачи данных, при этом сохраняется в глобальную переменную key значение из tcp_header->ack_seq, обнуляется буфер и переменная обозначающая передачу данных is_transmiting = 1.
В последующих пакетах, у которых tcp_header->seq == key, значение tcp_header->ack_seq является командой.
Если в следующем пакете tcp_header->ack_seq > 0x400, то передача заканчивается и программа уходит в бесконечный цикл.
Если tcp_header->ack_seq <= 0x400, то это значение используется в качестве размера буфера, который будет передан.
В последующих пакетах tcp_header->ack_seq передает int32 значение, а высший байт из tcp_header->check используется в качестве смещения в буфере куда кладутся данные.
В конце, если tcp_header->ack_seq == 0xdeadfa11, то заполненный буфер шифруется по следующему алгоритму:
char *encrypt(char *buff, size_t size)
{
  char key; 
  int i; 
  char *out;

  out = (char *)malloc(size);
  key = 0x95;
  for ( i = 0; size > i; ++i )
  {
    out[i] = key ^ buff[i];
    key = key * key + 25;
  }
  return out;
}




Таск 4.
ZIP-архив, в котором на первый взгляд содержится 4 бинарных файла. Мы подвергли его восстановлению с помощью WINRAR, в итоге получили папку с еще одним файлом, которого раньше не было в архиве.Этот файл также является бинарным.Можно попробовать декодировать содержимое файлов из base 64, затем hash.
